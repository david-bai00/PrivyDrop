---
title: "EmpÃªcher lâ€™IA de dÃ©railler : une mÃ©thode de collaboration vraiment applicable (avec templates)"
description: "Votre IA part dans tous les sens quand elle code ? Transformez Codex/Claude en vrai coÃ©quipier grÃ¢ce Ã  AGENTS.md, un AI Playbook et un workflow plan-first : moins de retours en arriÃ¨re, plus de maintenabilitÃ©. Exemples Next.js inclus."
date: "2025-12-26"
author: "david bai"
cover: "/blog-assets/ai-collaboration-playbook.webp"
tags:
  [
    "Collaboration IA",
    "Codex",
    "Processus dâ€™ingÃ©nierie",
    "Open Source",
    "Next.js",
  ]
status: "published"
---

![](/blog-assets/ai-collaboration-playbook.webp)

Vous avez dÃ©jÃ  vÃ©cu Ã§a ?

- Vous demandez Ã  lâ€™IA de corriger un bug, et elle modifie aussi du code hors sujet â€” puis vous devez revenir en arriÃ¨re Ã  la main
- Vous Ã©crivez des tonnes de prompts, mais elle ne trouve pas les bons fichiers et finit par â€œdevinerâ€
- Au milieu dâ€™une longue discussion, elle oublie les contraintes et la qualitÃ© chute brutalement

Si vous utilisez lâ€™IA comme â€œune recherche plus rapideâ€, ces problÃ¨mes restent invisibles. Mais dÃ¨s que vous la considÃ©rez comme â€œun coÃ©quipierâ€, ils impactent directement la qualitÃ© de livraison.

Cet article prÃ©sente une **mÃ©thode dâ€™ingÃ©nierie exÃ©cutable** pour transformer la collaboration IA â€” de la â€œmagie de promptsâ€ vers un **processus reproductible**. Dans PrivyDrop, aprÃ¨s adoption, lâ€™ajout de features et les bugfixes sont devenus plus rapides et plus stables : non pas en prenant plus de risques, mais en rÃ©duisant les retours en arriÃ¨re.

Ã€ la fin, vous obtenez une structure minimale copiable dans nâ€™importe quel repo :

- `AGENTS.md` : contraintes du repo (lignes rouges, valeurs par dÃ©faut, dÃ©finition de done)
- `docs/ai-playbook/index.md` : point dâ€™entrÃ©e 1 page (haute densitÃ© de signal)
- `docs/ai-playbook/code-map.md` : carte du code (oÃ¹ changer)
- `docs/ai-playbook/flows.md` : flows clÃ©s (comment Ã§a tourne)
- `docs/ai-playbook/collab-rules.md` : rÃ¨gles de collaboration + template de plan de changement (comment on travaille)

Tous les exemples viennent du repo open source PrivyDrop :
[<u>**https://github.com/david-bai00/PrivyDrop**</u>](https://github.com/david-bai00/PrivyDrop)

OpenAI a aussi publiÃ© un retour dâ€™expÃ©rience trÃ¨s proche dans lâ€™esprit :
[<u>**https://openai.com/index/shipping-sora-for-android-with-codex/**</u>](https://openai.com/index/shipping-sora-for-android-with-codex/)

---

## Step 0 : dÃ©finir les limites et le â€œdoneâ€ (ne pas commencer par les prompts)

Ce step fait une seule chose : rendre explicite ce que â€œterminÃ©â€ veut dire. Sinon, lâ€™IA optimise pour â€œÃ§a marcheâ€, pas pour â€œÃ§a marche durablement et maintenablementâ€.

Trois contraintes minimales :

1. **Boundary** : ce qui ne doit jamais arriver (privacy/architecture red lines, compatibilitÃ© de protocole, guardrails de paramÃ¨tres critiques)
2. **Scope** : un objectif par changement, pas de â€œtant quâ€™on y estâ€¦â€
3. **Done** : build/tests + checklist de rÃ©gression manuelle Ã  Ã©crire

Ã€ mettre en une phrase en tÃªte de chaque demande :

```text
Un seul objectif, plan dâ€™abord ; ne jamais franchir les red lines privacy/architecture ; done = build OK + checklist de rÃ©gression.
```

---

## Antiâ€‘patterns frÃ©quents

Avant de commencer, voici les 3 erreurs les plus courantes :

1. **Demander Ã  lâ€™IA de â€œmodifier le codeâ€ sans plan**

   - RÃ©sultat : 10 fichiers modifiÃ©s, puis vous rÃ©alisez que la direction Ã©tait mauvaise â€” rollback douloureux
   - Mieux : exiger un plan de changement ; implÃ©menter seulement aprÃ¨s approbation

2. **Tout jeter dans le prompt (overload de contexte)**

   - RÃ©sultat : surcharge ; lâ€™IA ne voit plus le signal (elle ne retrouve mÃªme pas les entry points)
   - Mieux : un index haute-signal + une code-map

3. **Laisser lâ€™IA â€œoptimiser au passageâ€**
   - RÃ©sultat : un PR mÃ©lange plusieurs objectifs ; le coÃ»t de review explose ; les bugs sont plus difficiles Ã  revert
   - Mieux : single-scope, changements minimaux et facilement revertables

---

## Step 1 : Ã©crire `AGENTS.md` (contraintes du repo, rÃ©utilisables)

Pensez Ã  `AGENTS.md` comme Ã  une version â€œmachine-readableâ€ des â€œvaleurs par dÃ©fautâ€ et des â€œlignes rougesâ€ de votre Ã©quipe. Son rÃ´le nâ€™est pas dâ€™expliquer la thÃ©orie : câ€™est dâ€™Ãªtre **rÃ©appliquÃ© Ã  chaque session**.

Dans PrivyDrop, cinq lignes suffisent pour capturer lâ€™essentiel :

- Plan first : `AGENTS.en.md:7`
- One change, one purpose : `AGENTS.en.md:8`
- Privacy & architecture red line : `AGENTS.en.md:9`
- Docs must stay in sync : `AGENTS.en.md:12`
- Verification required : `AGENTS.en.md:13`

Fichier : [<u>**AGENTS.en.md**</u>](https://github.com/david-bai00/PrivyDrop/blob/main/AGENTS.en.md)

Si vous partez de zÃ©ro, voici une forme minimale (courte, stricte, actionnable) :

```md
# AGENTS â€” Repo Rules

First Principles

- Plan-first: Propose a change plan and get approval before writing code
- Single-scope: One PR solves one goal; avoid â€œwhile Iâ€™m hereâ€ fixes
- Redlines: Never cross privacy/architecture/protocol/key-parameter guardrails
- Docs-sync: Keep the playbook docs in sync when entry points/flows/interfaces change
- Validation: Must include build/tests and key manual regression checklist
```

### Support multilingue

Si votre repo doit fonctionner dans plusieurs langues, un pattern pragmatique :

- Garder `AGENTS.en.md` comme version canonique
- Ajouter des variantes localisÃ©es au besoin (ex. `AGENTS.<locale>.md`)
- AprÃ¨s le clone, chaque contributeur crÃ©e localement un symlink selon sa langue :

```bash
# Utilisateurs anglais
ln -s AGENTS.en.md AGENTS.md
```

- Ajouter `AGENTS.md` Ã  `.gitignore` pour Ã©viter les conflits de symlink

> **IdÃ©e clÃ©**  
> Le secret dâ€™une collaboration IA fiable nâ€™est pas â€œde meilleurs promptsâ€. Câ€™est â€œde faire des contraintes une partie du repoâ€. `AGENTS.md` rend les rÃ¨gles rÃ©utilisables, et lâ€™AI Playbook rend le contexte durable.

---

## Step 2 : `docs/ai-playbook/index.md` (entrÃ©e hauteâ€‘signal)

Lâ€™une des raisons les plus frÃ©quentes du â€œdriftâ€ : **lâ€™IA ne connaÃ®t pas vos vrais entry points**. Du coup, elle â€œdevineâ€ oÃ¹ changer.

Votre index doit faire deux choses :

- Se lire en 30 secondes : seulement â€œproject snapshot + link indexâ€
- Offrir une navigation en un clic : emmener le lecteur/lâ€™IA vers code-map / flows / collab-rules

RÃ©fÃ©rence : [<u>**docs/ai-playbook/index.md**</u>](https://github.com/david-bai00/PrivyDrop/blob/main/docs/ai-playbook/index.md)

Template minimal (copiable) :

```md
# AI Playbook â€” Index

## Project Snapshot

- Stack: Next.js / Node / ...
- Red lines: ...

## Document Index

- Code map: docs/ai-playbook/code-map.md
- Key flows: docs/ai-playbook/flows.md
- Collaboration rules: docs/ai-playbook/collab-rules.md
```

---

## Step 3 : `code-map.md` (oÃ¹ changer)

La code-map sert Ã  â€œse repÃ©rer viteâ€, pas Ã  â€œvous apprendre Ã  implÃ©menterâ€. Les rÃ¨gles dâ€™Ã©criture sont simples :

- Lister uniquement les dossiers clÃ©s et les fichiers dâ€™entrÃ©e (entry files)
- Une phrase par entry file : sa responsabilitÃ©
- Ã€ lâ€™arrivÃ©e dâ€™une demande : viser 3â€“8 fichiers candidats via la code-map, puis lire en profondeur

RÃ©fÃ©rence : [<u>**docs/ai-playbook/code-map.md**</u>](https://github.com/david-bai00/PrivyDrop/blob/main/docs/ai-playbook/code-map.md)

Optionnel : ajouter un mini â€œrequÃªtes courantes â†’ entry pointsâ€ pour rÃ©duire encore le coÃ»t de recherche :

```md
Routage des demandes courantes

- Nouvelle page / SEO: frontend/app/\*\*/page.tsx + metadata.ts
- Textes i18n: frontend/constants/messages/\*
- Blog: frontend/content/blog/\* + frontend/lib/blog.ts
```

Comment gÃ©nÃ©rer (et itÃ©rer) une code-map :

- PremiÃ¨re version : demander Ã  lâ€™IA de rÃ©sumer â€œrÃ©pertoires + entry points clÃ©sâ€ pour naviguer â€” pas pour Ãªtre exhaustif.
- ItÃ©ration : la traiter comme un document vivant. La mettre Ã  jour par incrÃ©ments Ã  chaque PR/commit (liste de fichiers), plutÃ´t que de la rÃ©Ã©crire.

---

## Step 4 : `flows.md` (comment Ã§a tourne)

Si la code-map rÃ©pond Ã  â€œoÃ¹ changerâ€, `flows.md` rÃ©pond Ã  â€œcomment Ã§a tourneâ€. Câ€™est extrÃªmement prÃ©cieux pour lâ€™IA :

- Si vous Ã©crivez la sÃ©quence et les invariants, lâ€™IA arrÃªte de â€œpatcher au feelingâ€
- Vous pouvez condenser les piÃ¨ges historiques en checklist de debug rÃ©utilisable

RÃ©fÃ©rence : [<u>**docs/ai-playbook/flows.md**</u>](https://github.com/david-bai00/PrivyDrop/blob/main/docs/ai-playbook/flows.md)

Au minimum, inclure :

1. **Key flow / sequence** (Mermaid si utile)
2. **Debug checklist** (logs/Ã©tats les plus importants)
3. **Micro-plan template** (forcer plan-first avant de coder)

Comment gÃ©nÃ©rer (et itÃ©rer) les flows :

- PremiÃ¨re version : demander Ã  lâ€™IA de reformuler le flux end-to-end + sÃ©quence + invariants. Vous relisez/corrigez (surtout les red lines et invariants), puis vous le figez en doc.
- ItÃ©ration : le maintenir Ã  jour par incrÃ©ments dÃ¨s quâ€™une interface/sÃ©quence change.

---

## Step 5 : rendre â€œplan firstâ€ obligatoire

Câ€™est lÃ  que lâ€™accÃ©lÃ©ration devient rÃ©elle : dÃ©placer la review plus tÃ´t â€” de â€œlire un diffâ€ Ã  â€œlire un planâ€.

Mettez le template de plan dans `collab-rules.md` et traitez-le comme une contrainte dure.

Template PrivyDrop : [<u>**docs/ai-playbook/collab-rules.md**</u>](https://github.com/david-bai00/PrivyDrop/blob/main/docs/ai-playbook/collab-rules.md)

Vous pouvez rÃ©utiliser directement cette structure (goals/scope/approach/risks/acceptance/rollback/validation) :

```text
Title: <short, clear title>

Goals
- <what you want to achieve>

Scope / Files
- <list of files youâ€™ll change/add + why>

Approach
- <implementation plan and key design points>

Risks & Mitigations
- <risk> â†’ <mitigation>

Acceptance Criteria
- <verifiable acceptance items>

Rollback
- <how to revert quickly>

Docs to Update
- docs/ai-playbook/index.md / code-map.md / flows.md / collab-rules.md / others?

Validation
- Build: next build
- Manual: <key cases & regression points>
```

En pratique, un workflow plus stable :

1. Lire lâ€™index + code-map + flows (read-only, pas de changement de code)
2. Reformuler lâ€™Ã©tat actuel et les contraintes avec vos mots (vous corrigez une fois)
3. Produire un plan de changement (implÃ©mentation seulement aprÃ¨s approbation)

> **Guide antiâ€‘piÃ¨ges**  
> Corriger la direction au stade du plan, Ã©viter de construire puis dÃ©molir ; le single-scope rend le rollback moins coÃ»teux et les merges plus simples.

---

## Step 5.1 : endurance du contexte (checkpoint â†’ nouveau chat)

Sur une tÃ¢che longue, la baisse de qualitÃ© est presque inÃ©vitable. Transformez lâ€™â€œenduranceâ€ en rÃ©flexe : quand vous voyez du guessing, des contraintes oubliÃ©es, ou du drift â€” Ã©crivez lâ€™Ã©tat dans un fichier puis repartez dans une nouvelle conversation ; ou faites un passage â€œcompress/summarizeâ€ pour rÃ©duire le contexte avant de continuer.

Template de handoff minimal (Ã  mettre dans `docs/ai-playbook/handoff.md` ou un fichier temporaire) :

```md
# Handoff

## Problem statement (3â€“5 sentences)

## Confirmed plan (bullets)

## Done / Not done

## Key files and entry points

## Red lines and invariants

## Acceptance & regression checklist

## Next-step checklist
```

Le but nâ€™est pas â€œune belle docâ€, mais de dÃ©placer le contexte de la fenÃªtre de chat vers un fichier que la session suivante peut relire de faÃ§on fiable.

---

## Step 6 : boucler la boucle (traiter lâ€™agent comme un nouveau coÃ©quipier)

Une fois les piÃ¨ces ci-dessus en place, la collaboration devient un pipeline stable :

1. Demande â†’ contraintes (citer `AGENTS.md`)
2. Navigation â†’ entry points (citer `index + code-map`)
3. Alignement â†’ sÃ©quences (citer `flows`)
4. Planification â†’ mini design doc (citer le template `collab-rules`)
5. ImplÃ©mentation â†’ petit changement single-scope (rollback facile)
6. VÃ©rification â†’ `next build` + points de rÃ©gression manuelle clÃ©s
7. Sync â†’ garder les docs playbook Ã  jour

Le bÃ©nÃ©fice le plus visible : livrer des features et corriger des bugs devient plus rapide et plus stable. Surtout, le â€œrapideâ€ vient de **moins de rework**, pas de plus de risque :

- Corriger la direction au stade du plan ; Ã©viter de jeter du travail
- Le single-scope garde le rollback peu coÃ»teux et les merges faciles
- Les flows transforment les piÃ¨ges passÃ©s en checklist rÃ©utilisable

Si vous voulez ajouter une â€œbarriÃ¨reâ€, mettez ces deux questions dans votre template de PR :

- Est-ce que ce PR inclut un lien/rÃ©sumÃ© de plan de changement ?
- Est-ce que `docs/ai-playbook/*` a Ã©tÃ© mis Ã  jour (si entry points/flows/interfaces ont changÃ©) ?

## Exemples de prompt (copiables)

Une fois votre AI Playbook prÃªt, vous pouvez lancer une session avec quelque chose comme Ã§a :

---

**Role**

You are a senior Next.js full-stack engineer with strong product instincts. Your collaboration quality determines whether this repo can iterate sustainablyâ€”be thorough and professional.

**Task kickoff**

Please read `docs/ai-playbook/index.md` to understand the project context, code map, and collaboration rules. The current request is: "xxx".

**Working style**

Please deeply read relevant docs/code. Think systematically, ask clarifying questions, then propose analysis + a change plan for review. Implement only after approval.

---

**Pourquoi Ã§a marche**

- **Role** : fixe la barre de qualitÃ© et les responsabilitÃ©s
- **Task kickoff** : force la lecture du playbook au lieu de deviner
- **Working style** : rend â€œplan firstâ€ obligatoire dans le workflow

---

## RÃ©fÃ©rence du secteur : comment OpenAI utilise Codex pour organiser un sprint

Dans â€œHow we used Codex to build Sora for Android in 28 daysâ€, OpenAI dÃ©crit un workflow trÃ¨s proche de ce playbook :
[<u>**https://openai.com/index/shipping-sora-for-android-with-codex/**</u>](https://openai.com/index/shipping-sora-for-android-with-codex/)

Points clÃ©s Ã  aligner :

- Traiter lâ€™agent comme un nouveau senior : capable, mais a besoin dâ€™une architecture/contraintes explicites
- Externaliser les rÃ¨gles : un `AGENTS.md` solide paie sur la durÃ©e
- Plan avant changements rÃ©els : un plan est une mini design doc â€” on debug le plan avant le code
- Endurance du contexte : quand on atteint la limite, on Ã©crit le plan dans un fichier pour la session suivante
- ParallÃ©lisme multi-session : plus proche de â€œmanager une Ã©quipeâ€ que dâ€™utiliser un seul outil

Android et le web sont diffÃ©rents, mais la mÃ©thode transfÃ¨re : **amÃ©liorez les inputs, et les outputs se stabilisent**.

---

## Structure minimale de dossiers (copiable)

```text
AGENTS.en.md             # Canonical rules (English)
AGENTS.<locale>.md       # Optional localized rules
AGENTS.md                # Symlink (created locally after git clone)
docs/
  ai-playbook/
    index.md             # High-signal entry point
    code-map.md
    flows.md
    collab-rules.md
```

---

Si vos docs sont dÃ©jÃ  dispersÃ©es partout : commencez par `index.md` pour rassembler les entry points, puis complÃ©tez code-map/flows/templates.

---

## Prochaines Ã©tapes

1. **Commencer maintenant** : copiez la structure minimale dans votre repo et dÃ©marrez par `AGENTS.md`
2. **ImplÃ©mentation de rÃ©fÃ©rence** : visitez [<u>**PrivyDrop GitHub**</u>](https://github.com/david-bai00/PrivyDrop) et parcourez lâ€™AI Playbook complet
3. **Feedback** : si Ã§a vous aide (ou si vous tombez sur des piÃ¨ges), ouvrez un issue GitHub ou laissez un commentaire
4. **Star** : si Ã§a a de la valeur, mettez une Ã©toile Ã  PrivyDrop ğŸŒŸ

---

## Conclusion

Le dÃ©veloppement assistÃ© par IA ne rÃ©duit pas lâ€™exigence de rigueur : il lâ€™augmente. La vitesse durable vient de contraintes claires, de plans approuvÃ©s, de flows documentÃ©s et dâ€™un contexte qui survit aux conversations.

Si vous voulez aller plus loin, vous pouvez faire Ã©voluer cette mÃ©thode en â€œscaffold de repo copiableâ€ : templates de PR, templates dâ€™issues, et un starter kit `AGENTS.md` + playbook prÃªt Ã  lâ€™emploi.
